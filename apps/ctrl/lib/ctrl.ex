defmodule Brewberry.Ctrl do
  use Application

  @moduledoc false

  alias Brewberry.Controller
  alias Brewberry.ControllerLoop
  alias Brewberry.Heater
  alias Brewberry.MashTemperature
  alias Brewberry.Measure
  alias Brewberry.TimeSeries

  @measure_backend Application.get_env(:ctrl, :measure_backend)
  @heater_backend Application.get_env(:ctrl, :heater_backend)

  @doc """
  Entrypoint for the Ctrl (controller) application.

  Set the mash temperature with `Brewberry.MashTemperature.set!`.
  Read the actual state via `Brewberry.ControllerLoop.state?`.
  The controller can be switched on and off by calling
  `Brewberry.Controller.resume` and `pause`.
  """
  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      worker(Measure, [@measure_backend], restart: :permanent),
      worker(MashTemperature, [], restart: :permanent),
      worker(Controller, [], restart: :permanent),
      worker(Heater, [@heater_backend], restart: :permanent),
      supervisor(Registry, [:duplicate, SampleNotification], restart: :permanent),
      worker(TimeSeries, [], restart: :permanent),
      worker(ControllerLoop, [], restart: :permanent)
    ]

    opts = [strategy: :one_for_one, name: Brewberry.Ctrl]
    Supervisor.start_link(children, opts)
  end


  @doc """
  Register the current process for new samples and state changes on
  the controller.
  """
  def register() do
    Registry.register(SampleNotification, :sample, [])
  end

  def unregister(_arg \\ nil) do
    Registry.unregister(SampleNotification, :sample)
  end

  def listener(_arg \\ nil) do
    receive do
      {:sample, sample} -> {[{sample.time, sample}], nil}
    end
  end

  @doc """
  Listen to events generated by the controller and expose them as a stream of events.
  A `{id, sample}` tuple is returned.
  """
  def stream do
    Stream.resource(&register/0, &listener/1, &unregister/1)
  end

end
